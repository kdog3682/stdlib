/* prettier-ignore */ import {pause, fooga, getBindingValueString, templater2, smartDedent5, pop3, moduleExports, joinPath, expandPath, isDecimal, hasPercentage, parsePercentage, Matrix, isInteger, isEquation, isObjectObject, getExtraIndent, shellUnescape, assertEqual, asyncToggle, touched, chosen, lastOf, firstOf, isBlockEnter, group3, loremIpsum, exportString, deepToggle, maybeNewlineIndent, onAndOff, flattenModule, isModule, isNativeHtmlTag, partitionByValues, strcall, getLongest2, must, mconfig, unreachable, notify, storager, joiner, removeVeryStartingComments, ireplace, removeCommentsInPlace, editf, getLineTokens, IndexedStore, abstractError, bool, xassert, getSetLines, inMiddle, replaceLast, ensureExtension, multipleReplacer, getGradeLevel, constructEdit, getYear, Modulus, wrapClassMethods, proseReplacer, parseComments, parseFunctionDictComments, todo, dictAssertion, boundModularIncrement, construct, reduceToString2, pageTurner, assignCumulative, defaultMergeStrategy, dictSetter3, toArguments, reTemplate, parseFrontmatter, typeAssertion, defineGetter, assignAllowed, simpleRecursiveWalk, simpleArgument, exprTemplater, stringifyIfNotPrimitive, panic, stringerf, wrapFunction, regexTemplater, iso8601, strftime, walkChildEntries, getFiletype, matchf, isUrl, looksLikeFunction, toArgument2, notNull, CumulativeStorage2, simpleAssign, findAndMatch, infuseObjectArray, regexGetter, splitArg, isJavascriptComment, runTest, everyOther, splitByRange, get_regex, getImports, isJavascriptFile, isValidDateString, WriteObject, equalityf, group2, splitOnce2, dedent4, isLowerCase, looksLikeRegExpString, isRegExpString, getDependencies, camelSplit, toggle3, countf, isLiteralObject, bindMethodsAndState2, call, mget3, looks_like_object_function, create_functions_from_master, toStringArgumentPretty, codeChunks, smart_map, run_tests, hasStartingCallable, mapTemplate, aliaser, fixSelector, htmlTags, removePythonComments, simpleStringBreaker, colonConfig, operations, error, redColon, so2, group, parseSingleLineJson, Items, findDependencies, tryf, find4, localeString, cssComment, colonConfigf, trimArray, parseCallable, bringToLifeTextFix, localBringToLife, getCaller4, getErrorStack, forEach, getBindings, getExports, matchstr, filter4, allEqual, count, isNativeFunction, repeat, eat, getIndentAndText, StopWatch, stringDictSetter, getFunctionInfo, runRef, toLines, hasCallable, getProseWords, tally, paramify, codeSplit, debugConfig, logConfig, blueColon, toStringArgument3, stringCallable, simpleBinding, dashSplit4, appendBelow, appendAbove, removeLineComments, prependIfNecessary, smartDedent4, blueSandwich, walk4, findLineIndex, parseAB, applyTransform, kebabCase, getExcerpt, sortObject, buildFunction, maybeSort, parseFunction, isTypable, frontMatter, dictEntry, insertAfterIndex, State, bindMethods, cpop, tagRE, toggle2, createFunction2, assignIncrementedIndex, ufa, assignArray, regexFromComment, createParsersFromObject, imatch, globalConsoleDebug, bindMethodsAndState, isQuestion, oxfordComma, isUpperCase, getFunctionIdentifier, filter3, match, getMatch, alternatef, reCombine, assertion2, deepEqual, hasDollar, so, deepAssign, Tally, getFunctionNames, throwError, notEqual, tryString, prettyPrintCodeSnippet, prettyPrintErrorStack, iter, quotify, transformerf, assign, defineBinding, jspy, linebreak, stringCall2, reduce3, getClassParameters, assignOnTop2, isIdentifier, ndy, dashSplit3, runFunctionFromRef, equalf, alphabet, stateGetterFromSchema, mreplace, require, topLineComment, isChinese, replacef, ignoref, codeLibrary, splitLines, addArgumentQuotes, getBindings2, addCaret, mget2, getStartingConfig, incrementalEat, strlen, hr, setOnce, unescapeHtml, oxford, breakerf, runTests, map3, dateSplit, transformDict, walk3, toRegExp, tryAgainf, assertNotNull, getArgumentObject, isArgumentObject, typef, requireArg, keyAndValue, assignf, stateGetter3, objectFromArguments2, assignDefaults, transformValue, assign3, assignFresh3, evaluate3, scopedEvaluator, objectFromArguments, enforce, sub, filterObject, extractStartingJsonLikeConfig, unbrackify, newlineIndent2, deleteLine, both, normalizeIndent, getComment, secondComment, isStringRegExp, dashSplit2, clock, warning, errorStringify, alert, labelCase, bottomComment, stringCompose, getAnyIdentifier, chalkf, getNumbers, partitions, has, addUnit, toCallable, unquote, filter2, warn2, join2, caller2, assignOnce, longShort, shortLong, argPop, caller, assignOnTop, toggle, defineWindow, unescapeNewlines, escapeQuotes, unescapeQuotes, escapeNewlines, setAliases, announceCaller, removeStartingComments, smartBind, assignExisting, isObjectWithKey, eatStart, modularIncrementItem, getRegex, runFunction, isObjectLikeArray, itemGetter2, getAllKeys, prefixSlice, hasQuotes, assertion, diff, toggleState, initState, dunder, objectGetter, superTransform, popFilter, testRunner, assert2, insertAtDollar, popEmptyLine, getOptions, mergeSpecs, sortByKeys, map2, strictMessengerAssert, smartSplit, chalk4, typeLog, getFunctionName, Clock, search3, MyError, fuzzyMatch3, debugDisplay, getCaller3, messengerAssert, camelSlice, setPrototype, assignAliases, display, modifyNumber, toDict, setPush, modularIncrementIndex, longstamp, popIndex, toggleOnOff, locWrap, walk2, typeMatch, prettyStringify, getIdentifiers, CustomError, argMatch, brackify2, smartestDedent, modularIncrementNumber, AbstractMethodError, allUnique, Trie, boundarySplit, numberBoundarySplit, nodeLog, getFirst, defineProperty, supermix, partial, timeLog, timestamp, raise, getIdentifier, conditionalPrefix, conditionalSuffix, QueryList, fuzzyMatch2, buildDict, getTextAndCommand, sprawlFactory, getParameters2, pushf, intersection, union, blue, green, sandwich, getLastSpaces, smartDedent3, red, sort, debounce, checkValue, getCodeChunks, logf, boundary, myError, conditional, isStringFunction, toSpaces, objectf, searchAll, difference, singleQuote, itemGetter, slice2, mergeObjects, once, dashSplit, nchalk, coerceToObject, ArrayState, exporter2, indent2, iterator, removeAllComments, countParams, cumulativeSchemaAssign, argKwargSplit, argParse, removeInlineComments, getFrontMatter, hasHtmlSuffix, lazyArray, isThisFunction, escapeHTML, getKwargs2, search2, toStringArgument, createFuzzyMatch, edit2, splice, zip, merge2, argArgsKwargs, fill2, vueWrap, splitArray, splitArray2, warn, makeRunner2, searchf2, smartDedent2, dedent2, toArray2, stateGetter2, sortByIndex, IndexedCache, argo, curry2, doUntil2, evaluate2, findall2, findIndex2, findItem2, getCaller2, getErrorStack2, isJson, indexGetter2, insert2, pop2, parseError2, remove2, reduce2, testf2, type2, unshift2, waterfall2, xsplit2, Cache, cumulativeAssign, replaceBefore, topComment, isAsyncFunction, mapSort, getFileURI, getQuotes, isClassObject, isInitialized, getFallback, bindingRE, addObjectOrObjectProperty, forDoubles, isCss, log, backAndForth, round, iteratorWrapper, toJSON, isFromMap, toString, empty, conditionalString, getConfigArg, hasKey, errorWrap, successWrap, check, toPoints, bind, mixinAliases, isPercentage, isBasicType, reducerStrategy, gather, entries, stateGetter, methodCase, vueCase, push2, smarterIndent, lineSplit, Store, isSingleLetter, prepareText, isSymbol, getShortest, slice, KeyError, deepCopy, argsKwargs, isError, isColor, list, objectEditor, matchall, makeFastRunner, announce, hasLetter, filter, reduce, stringCall, capitalizeName, stop, proseCase, lineDitto, mixinSetters, modularIncrement, distinct, definedSort, groupBy, reWrap2, fuzzyMatch, isPlural, Element, parseError, isPrimitiveArray, callableArgsKwargs, waterfall, defineVariable, info, flat2D, splitThePage, handleError, dedent, TypeAssertion, createFunction, pluralize, remove, Group, PageStorage, Storage, UniqueStorage, Watcher, arrayToDict, addProperty, addQuotes, argWrapFactory, assert, abrev, abf, addExtension, assignFresh, antif, atFirst, atSecond, backspace, bindObject, breaker, blockQuote, brackify, bringToLife, comment, countCaptureGroups, capitalizeTitle, classMixin, callableRE, camelToTitle, curry, createVariable, changeExtension, curryStart, curryEnd, capitalize, copy, camelCase, compose, char2n, camelToDash, deepMerge, datestamp, doublef, dictSetter, dictSetter2, dsearch, doUntil, dashCase, doubleQuote, dict, dictGetter, depluralize, dreplace, dictf, endsWithWord, exporter, edit, exists, evaluate, extend, find, flatMap, fill, fixUrl, functionGetter, findall, fixPath, flat, fparse, findIndex, firstLine, ftest, getKwargs, getFirstName, getBindingName, getParameters, getLastWord, getCodeWords, getCodeWords2, getIndent, getExtension, getLast, getLongest, getChunks, getCaller, getStackTrace, getConstructorName, getFirstWord, getWords, getSpaces, hasComma, hasSpaces, hasHtml, hasBracket, hasNewline, hasCaptureGroup, hasEquals, hasValue, hasCamelCase, hasNumber, hackReplace, insert, indexGetter, incrementf, isCallable, isQuote, isEven, isOdd, isLast, isHTML, isNode, interweave, inferLang, isString, isArray, isObject, isDefined, isFunction, isPrimitive, isNumber, isSet, isNestedArray, indent, isNull, isWord, isBoolean, isRegExp, identity, isObjectLiteral, isJsonParsable, isCapitalized, isNewLine, isObjectArray, isStringArray, isClassFunction, joinSpaces, join, keyArrayToObject, lowerCase, linebreakRE, len, lineGetter, lineCount, lastLine, logConsole, makeRunner, mixin, modularf, matchGetter, merge, mget, map, mergeOnTop, mergeToObject, mapFilter, noop, nestPush, no, newlineIndent, n2char, objectWalk, overlap, objectToString, opposite, pipe, parseTopAttrs, pascalCase, partition, parens, push, pop, parseJSON, rigidSort, removeQuotes, rep, removeComments, range, removeExtension, rescape, reverse, reWrap, reduceToString, repeatUntil, swapKey, sayhi, swap, splitMapJoin, splitCamel, smallify, search, stringify, shared, smartDedent, stringBreaker, sleep, split, snakeCase, stringArgument, sorted, splitOnce, searchf, secondLine, titleCase, textOrJson, toNumber, toArgument, toNestedArray, test, type, tail, transformObject, trim, testf, toArray, templater, totalOverlap, upperCase, unique, uncapitalize, unzip, wrap, walk, wrapf, xsplit, yes, zip2} from "/home/kdog3682/2023/utils.js"
import * as variables from "/home/kdog3682/2023/variables.js"
import * as chalk from "/home/kdog3682/2024-javascript/js-toolkit/chalk.js"

export {
    traverse,
    collectImports,
    is,
    evalTraversal,
    traverseWithEnvironmentAndRef,
    traverseJavascript,
    simpleCodeLibrary,
    iterateNode,
    findChildNodeRecursively,
    Environment,
    traverseJson,
    findallChildNodes,
    jsonTraversal,
    stringBuilder,
    isContentNode,
    iterateTree,
    getChildNodes,
    findChildNode,
    viewTree,
    traverseBlue,
    getNameNode,
    getStatef
    // findNode,
}
function findParentNode(node, fn) {
    const gn = lezerTestf(fn)
    while ((node = node.parent)) {
        if (gn(node, count++)) {
            return node
        }
    }
}
function iterateTree(lezerState, fn, topLevel, mode, cursorAsNode) {
    let useGetTextFunction
    let from
    let ignoreSmalls
    if (isObject(arguments[2])) {
        const o = arguments[2]
        topLevel = o.topLevel
        mode = o.mode || o.nodeAsText ? String : null
        cursorAsNode = o.cursorAsNode
        useGetTextFunction = o.useGetTextFunction
        from = o.from
        ignoreSmalls = o.ignoreSmalls
    }
    let { node, getText } = lezerState
    /* can we change tree to node? */
    if (from) {
        node = findChildNode(node, from, { recursive: true })
        assert(node, "in order to proceed, node needs to exist")
    }
    const cursor = node.cursor()
    const store = []
    if (topLevel) {
        cursor.next()
        do {
            const input = cursorAsNode ? cursor.node : cursor
            const arg = useGetTextFunction ? getText : getText(cursor)
            if (ignoreSmalls && input.name == getText(input)) {
                continue
            }
            const value = fn(input, arg)
            if (value === false) {
                return store
            }
            push2(store, value)
        } while (cursor.next(false))
    } else {
        while (cursor.next()) {
            const input = cursorAsNode ? cursor.node : cursor
            const arg = useGetTextFunction ? getText : getText(cursor)
            if (ignoreSmalls && input.name == getText(input)) {
                continue
            }
            const value = fn(input, arg)
            if (value === false) {
                return store
            }
            push2(store, value)
        }
    }
    const walker = (v) => {
        return type(v) == "BufferNode" ? getText(v) : v
    }

    return mode == String ? walk4(store, walker) : store
}

function traverse(lezerState, ref, ignore = []) {
    const { node, getText } =
        "getText" in lezerState
            ? lezerState
            : { node: lezerState, getText: null }

    const { onLeaf, onBranch, onBranchEnter, onStart, onEnd } = ref
    const value = run(node)
    return onEnd ? onEnd(value) : value

    function run(node, depth = 0) {
        const name = node.name
        if (ignore.includes(name)) {
            return
        }
        let child = node.firstChild
        const text = getText ? getText(node) : ""
        const isBranch = !!child

        if (isBranch) {
            if (onBranchEnter) {
                try {
                    const status = onBranchEnter(node, text, depth)
                    if (status === false) {
                        return null
                    }
                } catch (e) {
                    const errorInfo = {
                        name: node.name,
                        depth,
                        text,
                        e: e.toString(),
                        onBranchEnter: onBranchEnter.toString(),
                        message: "an error ocurred at traverse:onBranchEnter"
                    }
                    throw errorInfo
                }
            }

            const children = []
            do {
                const val = run(child, depth + 1)
                if (!isString(val)) {
                    // console.log('not a string:', child.name)
                }
                push2(children, val)
            } while ((child = child.nextSibling))

            if (onBranch) {
                try {
                    return onBranch(node, children, depth)
                } catch (e) {
                    const errorInfo = {
                        name: node.name,
                        depth,
                        text,
                        e: e.toString(),
                        onBranch: onBranch.toString(),
                        message: "an error ocurred at traverse:onBranch"
                    }
                    throw errorInfo
                }
            }
        } else {
            return onLeaf(node, text, depth)
        }
    }
}

function refStrategy(external = {}) {
    const getName = (node) => {
        const key = node.name
        return variables.symbolNameRef[key] || key
    }

    const store = []
    const watcher = new Watcher(getName)

    function onLeaf(node) {
        return getName(node)
    }

    function onBranch(node, args) {
        const name = node.name
        const params = paramify(args)
        const t = "$1($2) {\n    return\n},"
        const payload = templater(t, [name, params])
        if (watcher.isFresh(node) && !external.hasOwnProperty(name)) {
            store.push(payload)
        }
        return name
    }

    function onEnd(node) {
        return brackify("const ref = ", join(store))
    }
    return { onLeaf, onBranch, onEnd }
}

function show(node, text, depth) {
    if (text == null) {
        return
    }
    const prefix = node.firstChild ? "branch" : "leaf"
    const isBranch = prefix == "branch"
    const bold = isBranch
    const template = isBranch
        ? chalk.red(`[${prefix}]${node.name}`)
        : blueColon(`[${prefix}]${node.name}`, doubleQuote(text))
    const output = indent(template, depth)
    console.log(output)
}

const blueTraversal = {
    onLeaf: showLeaf,
    onBranchEnter: show
}
function traverseBlue(state) {
    if (arguments.length == 2) {
        state = { node: arguments[0], getText: arguments[1] }
    }
    return traverse(state, blueTraversal)
}

function showLeaf(node, text, depth) {
    if (text.length == 1 && text == node.name) {
        return
    }
    return show(node, text, depth)
}

function getState(node, text) {
    const { from, to, name } = node
    return text
        ? { name, from, to, text: text.slice(from, to) }
        : { name, from, to }
}
function getStatef(text, mode) {
    if (isFunction(text)) {
        return text
    }
    if (mode == "text") {
        return function getText(node) {
            return text.slice(node.from, node.to)
        }
    }
    return function getState(node) {
        const { from, to, name } = node
        const s = text.slice(from, to)
        return { name, from, to, text: s }
    }
}

function getBindingNode(node) {
    const names = {
        FunctionDeclaration: "firstChild.nextSibling",
        VariableDeclaration: "firstChild.nextSibling",
        ClassDeclaration: "firstChild.nextSibling",
        AssignStatement: "firstChild",
        VariableDefinition: "firstChild",
        ClassDefinition: "firstChild.nextSibling",
        FunctionDefinition: "firstChild.nextSibling",
        DecoratedStatement: "firstChild.nextSibling.firstChild.nextSibling"
    }
    if (names.hasOwnProperty(node.name)) {
        return dictGetter(node, names[node.name])
    }
}

function checkpointf(...args) {
    let items
    let r
    items = args[0]

    function test(s) {
        if (items && items.includes(s)) {
            return
        }
        if (r && r.test(s)) {
            return
        }
        return true
    }
    return test
}

function findChildNode2(node, x) {
    throw 'not in use'
    /* common */

    const fn = lezerTestf(x)
    const firstChild = node.firstChild
    if (!firstChild) {
        return
    }
    let next = firstChild.nextSibling
    while (next) {
        if (fn(next)) {
            return next
        }
        next = next.nextSibling
    }
}
function findChildNode(node, x, o = {}) {
    if (!node) {
        return 
    }
    /* findChildNode1 is prev ver */
    // return findChildNode1(...arguments)
    /* findChildNode1 has been edited */
    if (o.recursive) {
        return findChildNodeRecursively(node, x, o)
    }
    let depth = 0
    const fn = lezerTestf(x)
    let child = node.firstChild
    while (child) {
        if (fn(child)) {
            return child
        }
        child = child.nextSibling
    }
}

function lezerTestf(checkpoint) {
    if (isFunction(checkpoint)) {
        return checkpoint
    }
    if (checkpoint == null) {
        return yes
    }
    const fn = equalf(checkpoint)
    return function lambda(node) {
        return fn(node.name)
    }
}

function javascriptParamify(args) {
    let s = ""
    for (let i = 0; i < args.length; i++) {
        const arg = args[i]
        if (i == 0) {
            s += arg
        } else if (i == args.length - 1) {
            s += arg
        } else {
            s += arg
            if (arg == ",") {
                s += " "
            }
        }
    }
    return s
}

function createTraversal(ref, state) {
    const missing = []
    const enterRef = {}
    const exitRef = {}
    const leafRef = {}
    const bind = (fn) => {
        if (state) {
            return fn.bind(state)
        }
        return fn
    }

    for (const [k, v] of Object.entries(ref)) {
        if (isObject(v)) {
            if (v.enter) {
                enterRef[k] = bind(v.enter)
            }
            if (v.exit) {
                exitRef[k] = bind(v.exit)
            }
        } else if (k == "onEnd" || k == "onStart") {
            continue
        } else if (isLowerCase(k)) {
            leafRef[k] = bind(v)
        } else if (k.endsWith("Enter")) {
            enterRef[k.replace("Enter", "")] = bind(v)
        } else {
            exitRef[k] = bind(v)
        }
    }

    function onLeaf(node, text, depth) {
        const name = node.name
        if (leafRef.hasOwnProperty(name)) {
            return leafRef[name](node.parent, text)
        }
        const fn = exitRef[name]
        try {
            return fn ? fn(node, text) : text
        } catch (e) {
            throw `leaf error @ ${name}: ${e.toString()}`
        }
    }

    function onBranch(node, children) {
        const fn = exitRef[node.name]
        if (fn) {
            try {
                return fn(node, ...children)
            } catch (e) {
                throw `branch error @ ${node.name}: ${e.toString()}`
            }
        }
    }

    function onBranchEnter(node, text, depth) {
        const fn = enterRef[node.name]
        if (fn) {
            try {
                return fn(node, text, depth)
            } catch (e) {
                throw `onBranchEnter error @ ${node.name}: ${e.toString()}`
            }
        }
    }
    return {
        onLeaf,
        onBranch,
        onBranchEnter,
        onEnd: ref.onEnd,
        onStart: ref.onStart
    }
}

/* nice */
function lezerf(x) {
    switch (type(x)) {
        case "Null":
        case "Undefined":
            return
        case "Object":
        case "Array":
            return (node) => x.includes(node.name)
        case "Function":
            return x
        case "String":
            return (node) => node.name == x
    }
}
function findNode(node, target) {
    const fn = lezerf(target)
    let match
    const gn = (cursor) => {
        if (fn(cursor)) {
            match = cursor.node
            return false
        }
    }
    iterate(node, gn)
    return match
}

function viewTree(x) {
    console.log(iterate(x, getState))
}
function iterate(x, fn, topLevel) {
    const cursor = getCursor(x)
    const store = []
    if (topLevel) {
        cursor.next()
        do {
            const value = fn(cursor)
            if (value === false) {
                return store
            }
            push2(store, value)
        } while (cursor.next(false))
    } else {
        while (cursor.next()) {
            const value = fn(cursor)
            if (value === false) {
                return store
            }
            push2(store, value)
        }
    }
    return store
}

function getCursor(x) {
    switch (type(x)) {
        case "LoremEditorView":
            return x.tree.cursor()
        case "BufferNode":
        case "TreeNode":
        case "Tree":
            return x.cursor()
        case "SyntaxNode":
            return x.cursor
        case "Cursor":
        case "TreeCursor":
            return x
    }
}

function getChildNodes(node, checkpoint) {
    if (!node) {
        return 
    }
    let child = node.firstChild
    const fn = lezerTestf(checkpoint)
    const store = []
    while (child) {
        if (fn(child)) {
            store.push(child)
        }
        child = child.nextSibling
    }
    return store
}
function isContentNode(node) {
    return node.name.length > 1
}

function getNameNode(node) {
    const ref = {
        VariableDeclaration: "firstChild.nextSibling",
        FunctionDeclaration: "firstChild.nextSibling",
        FunctionDefinition: "firstChild.nextSibling",
        ClassDeclaration: "firstChild.nextSibling",
        ClassDefinition: "firstChild.nextSibling",
        AssignStatement: "firstChild",
        ExpressionStatement: "firstChild.firstChild",
        CallExpression: "firstChild",
        NewExpression: "firstChild.nextSibling"
    }
    assert(node, "could not find a name node")

    const key = ref[node.name]
    if (key == "self") {
        return node
    }
    if (key) {
        const value = dictGetter(node, key)
        if (value) {
            return value
        }
    }

    /* NOTE: in-progress */
    switch (node.parent.name) {
        case "ArgList":
            return node.parent.parent.firstChild
        case "VariableDeclaration":
            return node.parent.firstChild.nextSibling
    }
}

// start of stringBuilder ## // 01-14-2024
//
//
//
function stringBuilder(state, ref) {
    ref = J2P
    const m = partition(ref, (k, v) => {
        return /Enter$/.test(k)
    })
    const [afterRef, beforeRef] = m.length == 1 ? [m[0], {}] : m
    const cache = new Cache()
    const vimState = {
        vim: {
            functions: {
                native: vim_native_functions,
                custom: ["abc"],
                user: ["abc"],
                modified: vim_modified_functions
            }
        }
    }
    const stringState = new VimStringState(vimState)
    const traversalRef = {
        onLeaf /* touches on enter */,
        onBranchEnter /* touches on enter */,
        onBranch /* handles the children */
    }
    return traverse(state, traversalRef)

    function onLeaf(node, text, depth) {
        // console.log({ name: node.name, text, depth, })
        return text
    }
    function onBranchEnter(node, text, depth) {
        const { name } = node
        const before = beforeRef[name + "Enter"]
        if (before) {
            before.call(stringState, node, text)
        }
        return null
    }
    function onBranch(node, children) {
        const after = afterRef[node.name]
        assertion2(afterRef, node.name)
        // console.log(['name', node.name, getText(node)])
        return after.call(stringState, node, ...children)
    }
}

function Script(node, ...args) {
    // console.log(node.name)
    // console.log(args)
    return join2(args, "\n")
    // console.log(this.missing)
    // return addMissing(this.missing)
    // return
}
function getVariableName(node, s) {
    const ref = {
        undefined: "None",
        lambda: "lambdaRunner"
    }
    return ref[s] || s
}
function pythonBody(items) {
    return newlineIndent(join2(items))
}

function commaString(args) {
    function fixCommas(x) {
        return x == "," ? ", " : x
    }
    return args.map(fixCommas).join("")
}

function objectOrArrayHandler(args, maxLength, mode) {
    const text = commaString(args)
    if (text.length > maxLength) {
        return _indent(args, Object)
    }
    return text

    function _indent(args, mode) {
        const [start, end] = mode == Array ? ["[", "]"] : ["{", "}"]
        const items = filter(args, testf(/^[,\[\]{}]$/, true))
        return `${start}\n${indent(items.join(",\n") + ",")}\n${end}`
    }
}
function toStringObject(...args) {
    const javascriptSuffixes = [
        "handler",
        "RE",
        "getter",
        "config",
        "transformer"
    ]

    const template = /[a-z]+(?:$1)$|^\(.*?\) *=>/i
    const magicRE = reWrap(javascriptSuffixes, template)
    const replaceRE = /^(?:\$|fn:)(\w+)$/

    if (!isObject(o)) {
        o = {}
    }

    assignFresh(o, {
        quote: javascriptObjectQuote,
        max_length: 68,
        lang: "javascript",
        indentation: 2,
        magic: false,
        beforeStart: identity
    })

    return parse(o.beforeStart(x), 0)

    function parseObj(obj, depth) {
        function parse_obj_helper(k, v) {
            if (isFunction(v) && !isNativeFunction(v)) {
                return [null, parseObjectFunction(k, v)]
            }
            const value = parse(v, depth + 1)
            return [k, value]
        }
        const computed = smart_map(obj, parse_obj_helper)
        return bracker(computed, "{}", depth, o)
    }

    function parseArr(arr, depth) {
        const computed = arr.map((x) => parse(x, depth + 1))
        return bracker(computed, "[]", depth, o)
    }

    function parseString(s) {
        s = s.toString()
        if (s == "''" || s == '""') {
            return "''"
        }
        if (replaceRE.test(s)) {
            return s.replace(replaceRE, "$1")
        }
        if (o.magic && magicRE.test(s)) {
            return s
        }
        if (/\n/.test(s)) {
            return `\`${escapeTilda(s)}\``
        }
        if (isRegExpString(s)) {
            return s
        }
        if (variables.commonFunctionNames.includes(s)) {
            return s
        }
        if (/^[\[\{]/.test(s) && /[\]\}]$/.test(s)) {
            return s
        }
        if (/^(?:new *)?\w+(?:\.\w+)?\(/.test(s)) {
            return s
        }
        return escapedSingleQuote(s)
    }

    function parse(s, depth) {
        if (s == null) return "null"
        if (s == undefined) return "undefined"
        if (s === "") return "''"
        if (s === true) return "true"
        if (s === false) return "false"
        if (s === "true") return "true"
        if (s === "false") return "false"

        switch (type(s)) {
            case "Object":
                return parseObj(s, depth)
            case "Array":
                return parseArr(s, depth)
            case "String":
                return parseString(s)
            case "Function":
                return s.name
            default:
                return s.toString()
        }
    }

    function parseObjectFunction(name, f) {
        const s = f.toString().replace(/\n\)/g, ")").replace(/\n\n}/g, "\n}")
        let [text, isAsync] = mget(/^async/, s)
        const prefix = isAsync ? "async " : ""
        text = text.replace(/function */, "")
        text = text.replace(/^ *\w+ */, "")

        let a = 1
        let b = text.match(/\n( *)\S.*$/)
        if (b) {
            b = b[1].length
            if (a < b) {
                text = text.replace(RegExp(`^ {${a},${b}}`, "gm"), "")
            }
        }
        return prefix + name + text
    }
}
class StringState {
    constructor(state) {
        this.options = {
            deleteEmptyFunctions: true,
            deleteEmptyBlocks: true,
            useDoubleQuotes: false,
            objectMaxLength: 10
        }
        Object.assign(this, state)
        this.missing = new Set()
        bind(this, "quote")
    }

    quote(s) {
        const fn = this.options.useDoubleQuotes ? doubleQuote : singleQuote
        return fn(s)
    }
    toJSON() {
        return {
            missing: Array.from(this.missing)
        }
    }
}

const J2P = {
    ClassDeclaration(node, ...args) {
        if (args.length == 5) {
            const [_, name, __, extendName, body] = args
            return `class ${name}(${extendName}):\n${newlineIndent(body)}`
        } else {
            const [_, name, body] = args
            return `class ${name}():\n${newlineIndent(body)}`
        }
    },

    ClassBody(node, leftBracket, body, rightBracket) {
        return body
    },

    MethodDeclaration(node, name, params, bodyItems) {
        const parent = node.parent
        let superValue = 1
        if (name == "constructor") {
            name = "__init__"

            const childNode = findChildNode(parent.parent, "extends")
            if (childNode) {
                bodyItems.value.unshift("super.__init__()")
            }
        }
        return `def ${name}${params}${pythonBody(bodyItems.value)}`
    },
    PropertyDefinition(node, s) {
        const parent = node.parent
        const nextName = node.nextSibling?.name
        if (nextName == null) {
            return s
        }
        if (nextName == "ParamList") {
            return s
        }
        return this.quote(s)
    },
    String(node, s) {
        return this.quote(s.slice(1, -1))
    },
    async() {
        return "async "
    },
    CompareOp(node, s) {
        if (s == "===") {
            return "=="
        }
        return s
    },
    BinaryExpression(node, ...args) {
        return args.join(" ")
    },
    ReturnStatement(node, returnKeyword, returnValue) {
        if (isObject(returnValue)) {
            if (returnValue.done) {
                return returnValue.value
            }
        }
        return `return ${returnValue}`
    },
    ArgList(node, ...args) {
        const [pure, objects] = partition(args, isString)
        if (empty(objects)) {
            return commaString(args)
        }
        const store = pure.filter(equalf(/^[(,)]$/, true))
        const kwargs = {}
        for (const object of objects) {
            // console.log({object})
            store.push(...toArray2(object.args))
            Object.assign(kwargs, object.kwargs)
        }
        for (const [k, v] of Object.entries(kwargs)) {
            store.push(`${k} = ${v}`)
        }
        return `(${paramify(store)})`
    },
    MemberExpression(node, ...fields) {
        const [a, b, c] = fields
        // console.log({a,b,c})
        if (a == "vim") {
            if (this.vim.functions.native.includes(c)) {
                return fields.slice(2).join("")
            } else if (hasKey(this.vim.functions.user, c)) {
                const method = this.vim.functions.custom[c]
                return method.concat(fields.slice(3)).join("")
            }
            // throw fields
            panic("invalid vim fields: $fields", { fields })
        }
        return fields.join("")
    },

    CallExpressionEnter(node) {
        if (node.firstChild.name == "MemberExpression") {
            return Object /*  */
        }
    },
    CallExpression(node, a, b) {
        if (!this.vim.functions.native.includes(a)) {
            a = capitalize(a)
        }
        if (node.parent.name != "ExpressionStatement") {
            return a + b
        }
        if (a == "Print") {
            return "ec " + b.slice(1, -1)
        }
        return "call " + a + b
        if (r.test(a)) {
            const [m, t] = eat(s, /\.(map|filter)$/)
            return `${m}(${t}, ${b}`
        }
        // console.log(node.firstChild.name)
        // console.log({a, b})
        // const parent = node.parent
        const ref = {
            "console.log": "print"
        }
        if (ref.hasOwnProperty(a)) {
            return ref[a] + b
        }
        return a + b
        const vimNatives = ["search"]

        const name = vimNatives.includes(a) ? a : capitalize(a)
        if (parent.name != "VariableDeclaration") {
            return "call " + name + b
        }
        return name + b
    },
    VariableDeclaration(node, prefix, binding, equal, value) {
        const parent = node.parent
        if (isFunction(value)) {
            const a = value(binding)
            return a
        }
        if (isObject(value)) {
            value = value.regex
        }
        if (parent.bindings) {
            parent.bindings.push(binding)
        }
        // console.log({binding, equal, value})
        return `${binding} ${equal} ${value}`
    },
    UnaryExpression(...args) {
        return args.join("")
    },

    ParenthesizedExpression(node, ...args) {
        return args[1]
        return args.join("")
        // return argleft, arg, right
    },

    AssignmentExpression(node, ...args) {
        return joinSpaces(args)
    },
    IfStatement(node, ...args) {
        // viewTree(node)
        // console.log(args)
        // throw ''
        return ifBuilder(...args)
        const [a, b, c, d, e] = args
        const elseWord = e && e.startsWith(":") ? "else" : "el"
        const payload = c.startsWith(":") ? c : ":" + newlineIndent(c)
        switch (args.length) {
            case 3: {
                return `${a} ${b}${payload}`
            }
            case 5: {
                return `${a} ${b}${payload}\n${elseWord}${e}`
            }
        }
    },

    ArrayPattern(...args) {
        return `[${args.join(", ")}]`
    },

    Property(...args) {
        if (args.length == 1) {
            const a = args[0]
            return `${this.quote(a)}: ${a}`
        }
        if (this.options.deleteEmptyFunctions && getLast(args) == " {}") {
            return
        }
        return args.join("")
    },
    [":"]() {
        return ": "
    },

    ExpressionStatement(node, s) {
        return s
    },

    Block(node, colon, ...args) {
        if (node.parent.name == "MethodDeclaration") {
            return { value: items }
        }
        return pythonBody(args.slice(0, -1))
    },

    FunctionDeclaration(parent, prefix, name, ParamList, Block) {
        const { bindings, value } = ParamList
        const aParams = bindings.map((a) => `let ${a} = a:${a}`)
        const body = Block
        const exclam = this.exclam ? "!" : ""
        const a_bindings = aParams.length ? newlineIndent(aParams) : ""
        return `function${exclam} ${name}${value}${a_bindings}${body}endfunction`
    },

    ParamList: handleParams,
    Script,
    BlockComment(parent, s) {
        const comment = getComment(s)
        return `"""\n${normalizeIndent(comment)}\n"""`
        return s
    },
    LineComment(parent, s) {
        return s.replace(/^\/+ */, '" ')
    },
    ArrayExpression(node, ...args) {
        return lezerBracker(args, { mode: Array })
        console.log(args)
        const maxLength = this.options.objectMaxLength
        return objectOrArrayHandler(args, maxLength, Array)
    },

    VariableName(node, s) {
        if (isFunctionDefinition(node.parent)) {
            return capitalize(s)
        }
        return s
    },
    UpdateStatement(...args) {
        return `let ` + joinSpaces(vimEditArgs(args))
    },

    ObjectExpression(...args) {
        const maxLength = this.options.objectMaxLength
        return objectOrArrayHandler(args, maxLength, Object)
    },
    TemplateString(...args) {
        return `f"${args.join("")}"`
    },
    Interpolation(a, value, c) {
        return `{${value}}`
    },
    null() {
        return "None"
    },
    VariableName: getVariableName,
    ArrowFunctionEnter(node, text) {
        // console.log(node.parent.prevSibling.name)
        // console.log(node.prevSibling.name)
    },
    ArrowFunction(node, ParamList, arrow, body) {
        // console.log(node.parent.name)
        if (isObject(ParamList)) {
            ParamList = ParamList.value
        }
        const paramString = ParamList
        return paramString + arrow + body
        return (name) => `def ${name}${paramString}${body}`
    },
    RegExp(parent, s) {
        const [r, f] = search(/^\/(.*?)\/(\w+)?$/, s)
        const regex = singleQuote(r)
        if (f) {
            const aliases = {
                i: "re.I",
                m: "re.M"
            }
            const flags = filter(f.split("").map(dictf(aliases)))

            const payload = { args: [regex], kwargs: { flags } }
            if (parent.name == "ArgList") {
                return payload
            }

            if (parent.name == "VariableDeclaration") {
                throw "ndy"
            }
        }
        return regex
    },
    FunctionExpression(parent, prefix, name, params, body) {
        if (parent.name == "ReturnStatement") {
            return {
                done: true,
                value: "def " + name + params + body + "\nreturn " + name
            }
        }
        ndy()
    },
    VariableDefinition: getVariableName,
    DefaultLabel(node) {
        return node
    },
    CaseLabel(caseKeyword, value) {
        return { value }
    },
    SwitchBody(parent, ...args) {
        args.shift()
        args.pop()
        const dn = args.findIndex(lezerTestf("DefaultLabel"))
        if (dn > -1) {
            const last = args.splice(dn, args.length - 1)
            args.push(join(last))
        }
        console.log(args)
        return partition(args)
    },
    SwitchStatement(parent, switchKeyword, switchVar, switchBody) {
        let s = ""
        switchBody.forEach(([a, b], i) => {
            if (i == 0) {
                s += `if ${switchVar} == ${a.value}:\n    ${b}\n`
            } else if (a.isDefault) {
                s += `else:\n    ${b}\n`
            } else {
                s += `elif ${switchVar} == ${a.value}:\n    ${b}\n`
            }
        })
        return s
    },
    ScriptEnter() {
        console.log("hi from enter script")
    }
}

function vimEditArgs(args) {
    for (let i = 0; i < args.length - 1; i++) {
        const [a, b] = args.slice(i, i + 2)
        if ((a == "+" || a == "+=") && !isNumber(b)) {
            args[i] = a.replace("+", ".")
        }
    }
    return args
}

function handleParams(node, ...args) {
    let touched
    const parent = node.parent
    const name = parent.name
    const paramBindings = []
    const fn = (arg) => {
        if (arg == "...") {
            touched = true
            return
        } else if (touched) {
            touched = false
            return "..."
        }
        if (isFunctionDefinition(parent) && !/^[,()]/.test(arg)) {
            paramBindings.push(arg)
        }
        return arg
    }
    const paramString = commaString(mapFilter(args, fn))
    return {
        value: paramString,
        type: "ParamList",
        bindings: paramBindings
    }
}
function isFunctionDefinition(parent) {
    return parent.name == "FunctionDeclaration"
}

function lezerBracker(args, o = {}) {
    console.log(args)
    return args.join("")
    const max_length = o.max_length || 20
    const mode = o.mode || Array
    const indentation = o.ind || 4
    const quote = o.quote || doubleQuote
    const lang = o.lang || "vim"
    const vimPrefix = lang == "vim" ? "\\" : ""
    const [a, b] = mode == Array ? ["[", "]"] : ["{", "}"]

    const parse = (item) => {
        if (mode == Array) {
            return item
        }
        if (item[0] === null) {
            return item[1]
        }
        if (item[0] === item[1] && lang == "javascript") {
            return item[0]
        }
        return quote(item[0]) + ": " + item[1]
    }

    const computed = items.map(parse)

    const value = a + computed.join(", ") + b

    if (value.length + depth * indentation < max_length && !hasNewline(value)) {
        return value
    }

    let s = a + "\n"
    for (const item of computed) {
        s += indent(vimPrefix + item, indentation) + ",\n"
    }
    s += vimPrefix + b
    return s
}
function ifBuilder(...args) {
    // console.log(args)
    const length = args.length
    let s = ""
    const aliases = {
        if: "if",
        "else if": "elseif",
        else: "else"
    }
    for (let i = 0; i < args.length; i++) {
        let arg = aliases[args[i]]
        if (arg == "else") {
            s += arg + args[i + 1]
            i += 1
        } else {
            let cond = args[i + 1]
            console.log(cond)
            let neg = false
            if (isIdentifier(cond.replace(/^!/, ""))) {
                if (cond.startsWith("!")) {
                    cond = stringCall2("empty", cond.slice(1))
                } else {
                    cond = stringCall2("Exists", cond)
                }
            }
            s += arg + " " + cond + args[i + 2]
            i += 2
        }
    }
    if (!s.endsWith("endif")) s += "endif"
    return s
}

class VimStringState extends StringState {}
const vim_native_functions = ["line", "getline", "expand", "len"]
const vim_modified_functions = [
    {
        name: "map",
        /* a custom transform function */
        transform(a, b) {}
    }
]
class ArrowFunction {
    constructor(options) {}
}

function traverseByClassObject(lezerState, classRef, ignore = []) {
    const { node, getText } =
        "getText" in lezerState
            ? lezerState
            : { node: lezerState, getText: null }

    const value = run(node)
    return value

    function run(node, depth = 0) {
        const name = node.name
        if (ignore.includes(name)) {
            return
        }
        let child = node.firstChild
        const text = getText ? getText(node) : ""
        const isBranch = !!child

        if (isBranch) {
            const state = {
                name: node.name,
                text,
                depth,
                from: node.from,
                to: node.to
            }
            const element = new classRef[node.name](state)
            element.enter()
            const children = []
            do {
                const val = run(child, depth + 1)
                if (!isString(val)) {
                    // console.log('not a string:', child.name)
                }
                push2(children, val)
            } while ((child = child.nextSibling))

            if (onBranch) {
                try {
                    return onBranch(node, children)
                } catch (e) {
                    const errorInfo = {
                        name: node.name,
                        depth,
                        text,
                        e: e.toString(),
                        onBranch: onBranch.toString(),
                        message: "an error ocurred at traverse:onBranch"
                    }
                    throw errorInfo
                }
            }
        } else {
            return onLeaf(node, text, depth)
        }
    }
}

// start of # environmental eval

function onLeaf(node, value) {
    if (value.length == 1 && node.name == value) {
        return
    }
    return {
        name: node.name,
        value
    }
}
function onBranch(node, children) {
    return {
        name: node.name,
        children
    }
}
const jsonTraversal = { onLeaf, onBranch }

function findallChildNodes(node, x, o = {}) {
    const fn = lezerTestf(x)
    const store = []
    const c = node.cursor()
    while (c.next() && c.to < node.to) {
        if (fn(c)) {
            store.push(c.node)
        }
    }
    return store
}
function findChildNodeRecursively(node, check, o = {}) {
    const fn = lezerTestf(check)
    const cursor = node.cursor()
    let depth = 0
    while (cursor.next() && cursor.from < node.to) {
        if (fn(cursor)) {
            depth += 1
            if (o.depth && depth != o.depth) {
                continue
            }
            return cursor.node
        }
    }
}

// iterateNode Is the next version of iterate tree.
// Changes:
// The third argument is now an object always
// the input Of the state Is not a tree But rather a node
// ignoreSmalls i mean is that small elements like commas hard ignored
// We can specify a starting point with the from option. If specified, it becomes the starting point of the iteration
// The runner has been extracted out into its own function

const defaultOpts = {
    topLevel: true /* gets toplevel function items       */,
    nodeAsText: true /* stringifys BufferNodes via getText */,
    cursorAsNode: true /* turns cursor into cursor.node      */,
    useGetTextFunction: true /* passes getText (fn) or text (str)  */
}
function iterateNode({ getText, node }, fn, o = {}) {
    assignFresh(o, defaultOpts)
    const topLevel = o.topLevel
    const mode = o.mode || o.nodeAsText ? String : null
    const cursorAsNode = o.cursorAsNode
    const useGetTextFunction = o.useGetTextFunction
    const from = o.from
    const ignoreSmalls = o.ignoreSmalls
    // throw o

    if (from) {
        node = findChildNode(node, from, { recursive: true })
        assert(node, "in order to proceed, node needs to exist")
    }

    const cursor = node.cursor()
    const store = []

    const runner = (cursor) => {
        const input = cursorAsNode ? cursor.node : cursor
        // console.log(cursorAsNode, type(input), type(cursor.node))
        const arg = useGetTextFunction ? getText : getText(cursor)
        if (ignoreSmalls && input.name == getText(input)) {
            return
        }
        const value = fn(input, arg)
        if (value === false) {
            return false
        }
        push2(store, value)
    }

    if (topLevel) {
        cursor.next()
        do {
            const status = runner(cursor)
            if (status === false) {
                break
            }
        } while (cursor.next(false))
    } else {
        while (cursor.next()) {
            const status = runner(cursor)
            if (status === false) {
                break
            }
        }
    }

    const walker = (v) => {
        return type(v) == "BufferNode" ? getText(v) : v
    }
    return mode == String ? walk4(store, walker) : store
}

function traverseJson(x, y) {
    const state = isFunction(y) ? { node: x, getText: y } : x

    function onLeaf(node, value) {
        if (value.length == 1 && node.name == value && value != "*") {
            return
        }
        return {
            name: node.name,
            value
        }
    }
    function onBranch(node, children) {
        return {
            name: node.name,
            children
        }
    }
    return traverse(state, { onLeaf, onBranch })
}



function simpleCodeLibrary(state, o = {}) {
    const runner = (node, getText) => {
        const nameNode = getNameNode(node)
        if (nameNode) {
            const value = o.asNode ? node : getText(node)
            return [getText(nameNode), value]
        }
    }
    let value = iterateNode(state, runner, {topLevel: true, nodeAsText: false})
    return o.asArray ? value : dict(value)
}

class Environment {
    constructor(parent, scope, options = {}) {
        this.options = options
        this.parent = parent || null
        this.missing = new Set()
        this.variables = new Map()
        for (const [k, v] of entries(scope)) {
            this.declareVar(k, v)
        }
    }
    check(name) {
        
    }
    resolve(name) {
        if (this.variables.has(name)) {
            return this
        }
        if (this.parent == null) {
            if (this.options.relaxed) {
                return
            } else {
                panic('$1 is undefined', name)
            }
        }
        return this.parent.resolve(name)
    }
    lookup(name) {
        if (isArray(name)) {
            return name.map((x) => this.lookup(x))
        }
        if (isObject(name)) {
            if (name.name == 'VariableName') {
                name = name.value
            } else {
                console.log(name)
                throw new Error('could not find name')
                throw name
            }
        }
        const env = this.resolve(name)
        if (env == null) {
            this.missing.add(name)
            console.log('name is missing: ', name)
            return 
        }
        // console.log('found a value for name', name)
        return env.variables.get(name)
    }
    assignVar(name, value) {
        // assigns to an existing variable name in the current scope
        // if not present, assigns higher
        // the existing variable must exist
        const env = this.resolve(name)
        env.variables.set(name, value)
        return value
    }
    declareVar(name, value, constant) {
        // declares a new variable in the scope
        // unlike assignVar, declareVar does not require existence
        if (constant && this.variables.has(name)) {
            throw new Error(`Cannot re-declare ${name} as it already exists as a constant`)
        }
        this.variables.set(name, value)
        // console.log('declaring a variable', name)
        return value
    }
    createEnv(items) {
        // the param validation has been moved to createLambda
        // here, we simply declare a new environment
        return new Environment(this, items, this.options)
    }

    createScope(items) {
        // the param validation has been moved to createLambda
        // here, we simply declare a new environment
        return new Environment(this, items, this.options)
    }
}

function traverseJavascript(x, y) {
    if (x.name == 'Script') {
        return x
    }
    const state = isFunction(y) ? {node: x, getText: y} : x

    const attrs = [
        "async",
        "Star",
        "const",
        "let",
    ]
    const hmm = [
        "Equals",
        "Star",
        "Arrow",
    ]
    const ignore = [
        "null",
        "undefined",
    ]


    function onLeaf(node, value, depth) {
        // if (node.name == 'VariableDefinition') {
            // return {
                // extend: { identifier: value }
            // }
        // }
        if (ignore.includes(node.name)) {
            return {
                name: node.name,
                value,
            }
        }
        if (node.name == value || hmm.includes(node.name)) {
            if (attrs.includes(node.name)) {
                return {
                    attr: value,
                    name: node.name,
                }
            }
            return 
        }
        return {
            name: node.name,
            value,
        }
    }
    function onBranch(node, args, depth) {
        const name = node.name
        const attrs = {}
        const children = []
        for (let i = 0; i < args.length; i++) {
            const arg = args[i]
            if (arg.extend) {
                Object.assign(attrs, arg.extend)
                continue
            }

            if (arg.attr) {
                attrs[arg.name.toLowerCase()] = true
                continue
            }
            if (arg.name == 'extends') {
                attrs[arg.name] = args[++i]
                continue
            }

            if (arg.name == 'Spread') {
                args[i + 1].spreadable = true
                continue
            }
            children.push(arg)

        }

        return {
            ...attrs,
            name,
            depth,
            children,
        }
    }
    return traverse(state, {onLeaf, onBranch})
}

function traverseWithEnvironmentAndRef(node, ref) {
    /* not in use */
    function fn(node, env, parent, children) {
        const name = node.name
        const action = ref[name]
        const value = action
            ? action(node, env, parent, children)
            : node.value
        return value
    }
    function run(node, env, parent) {
        const runner = (node) => run(node, env, parent)
        const children = mapFilter(node.children, runner)
        const value = fn(node, env, parent, children)
        if (type(value) == 'Environment' ) {
            env = value
            return 
        }
        return value
    }

    const parent = null
    const scope = null
    const options = {
        relaxed: true
    }
    const rootEnv = new Environment(parent, scope, options)
    return run(node, rootEnv)
}



function evalTraversal(ref) {
    /* not in use */
    const internalRef = {
        evaluateNode,
        evaluateStatements,
    }

    const parent = null
    const scope = null
    const options = {
        relaxed: true
    }
    const rootEnv = new Environment(parent, scope, options)

    function evaluateNode(node, env) {
        const fn = ref[node.name]
        if (fn) {
            if (node.children) {
                return fn.call(internalRef, node.children, env)
            }
            return fn.call(internalRef, node, env)
        }
    }
    
    function evaluateStatements(children, env) {
        let last = null
        for (const child of children) {
            if (child.name == 'Comment') {
                continue
            }
            last = evaluateNode(child, env)
        }
        return last
    }
    return function lambda(node) {
        return evaluateNode(node, rootEnv)
    }
}

function is(node, x) {
    if (isString(x)) {
        return node.name == x
    }
}
function collectImports(state, rootdir) {
    const slashed = (dir) => {
        return dir ? dir.replace(/\/$/, '') + '' : ''
    }
    const getFile = (node, dir) => {
        const s = state.getText(node).slice(1, -1)
        return s.replace(/^\W+/, slashed(rootdir))
    }
    const runner = (node, getText) => {
        if (is(node, 'ImportDeclaration')) {
            const importGroupNode = findChildNode(node, 'ImportGroup')
            const fileNode = findChildNode(node, 'String')
            const starNode = findChildNode(node, /star/i)
            const importNodes = getChildNodes(importGroupNode, /var/i) || [findChildNode(node, 'VariableDefinition')]

            return {
                filename: getFile(fileNode, rootdir),
                contents: importNodes,
                path: fileNode,
                star: !!starNode || !importGroupNode,
                text: node,
            }
        }
    }
    return iterateNode(state, runner)
}


